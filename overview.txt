A Beginner's Tutorial to a Stack-Based Scripting Language

1.0 Introduction: Welcome to a New Way of Thinking

Welcome to a unique scripting language designed from the ground up for the direct manipulation of data. At its heart is a simple yet powerful concept: the stack. Instead of juggling variables and complex syntax, you will learn to place data onto a stack and apply operations to it directly. This approach is particularly potent in web environments, providing a concise and expressive way to build dynamic, interactive user interfaces.

This tutorial is your guide to mastering this new paradigm. We will begin with the foundational principles of stack-based programming and progress step-by-step until you can build and understand a complete, data-driven web application. Every concept and example presented here is derived directly from the language's own interpreter, giving you a true-to-the-source understanding of its mechanics.

The Core Philosophy

The language is interpreted, but with a twist. As it reads your source text, it doesn't execute it immediately. Instead, it compiles the text into a series of executable JavaScript functions, as can be observed in its internal compile_element and interpret_element mechanisms. This creates an efficient, intermediate representation of your program.

Its design is concatenative and postfix. This means you build programs by chaining together "words" (the language's equivalent of functions or commands). The postfix nature means that operations always follow the data they operate on. For example, to add 2 and 3, you would write 2 3 +, which places 2 then 3 on the stack, and then the + word consumes them and pushes the result, 5.

Tutorial Structure

Our journey will be structured logically to build your knowledge from the ground up:

1. The Stack: We'll start with the language's central component, the data stack.
2. Core Logic: You'll learn to work with data types, define your own words, and control program flow.
3. Browser Integration: We will explore the language's powerful, built-in toolkit for creating and manipulating web pages, handling user events, and applying styles.
4. Case Study: We will culminate by dissecting a complete sample application, applying everything you've learned to understand it from start to finish.

Let's begin by diving into the most critical concept in the entire language: the stack.

2.0 The Core Engine: Understanding the Stack

The stack is the central workspace of the language. Imagine it as a vertical pile of data where you can only add or remove items from the top. This is known as a "Last-In, First-Out" (LIFO) data structure. Every operation in the language finds its inputs (arguments) on the top of the stack and places its outputs (results) back onto the top. Mastering the manipulation of this stack is the absolute key to mastering the language.

The language provides a set of fundamental words specifically for stack manipulation.

Word	Description
dup	Duplicates the top item on the stack.
swap	Swaps the top two items on the stack.
drop	Removes (discards) the top item from the stack.
2drop, 3drop, 4drop	Removes the top 2, 3, or 4 items from the stack.
r	Resets the stack, clearing all items.

Annotated Examples

Let's see these words in action. We'll show a piece of code and the state of the stack before and after it runs.

* dup: Duplicates the top value.
  * Code: 10 dup
  * Stack before: []
  * Stack after 10: [10]
  * Stack after dup: [10, 10]
* swap: Swaps the top two values.
  * Code: "hello" 5 swap
  * Stack before: []
  * Stack after "hello" 5: ["hello", 5]
  * Stack after swap: [5, "hello"]
* drop: Removes the top value.
  * Code: 1 2 3 drop
  * Stack before: []
  * Stack after 1 2 3: [1, 2, 3]
  * Stack after drop: [1, 2]
* 2drop: Removes the top two values.
  * Code: 1 2 3 2drop
  * Stack before: []
  * Stack after 1 2 3: [1, 2, 3]
  * Stack after 2drop: [1]
* r: Resets the entire stack.
  * Code: 1 2 3 r
  * Stack before: []
  * Stack after 1 2 3: [1, 2, 3]
  * Stack after r: []

Nearly every word you encounter will interact with the stack by consuming values from it or pushing new values onto it. Before we can perform more complex operations, we need to learn the syntax for creating the different types of data that can be placed on the stack.

3.0 Data and Literals: Working with Information

To perform any meaningful work, you first need to place data onto the stack. This section covers the language's basic data types and the specific syntax used to create them. When the interpreter encounters these literal values in your code, it knows to create and push the corresponding data onto the stack during execution.

3.1 Numbers

Numbers are the simplest data type. You write them directly in your code, and they are automatically pushed onto the stack when encountered. The interpreter uses a regular expression (number_regex) to identify numeric values, including integers and floating-point numbers.

Example: The code 10 -5 3.14 will result in the following stack: [10, -5, 3.14]

3.2 Strings

Strings are used to represent text. The language provides two distinct ways to create them.

1. Quoted Strings: To create a string that contains spaces or special characters, enclose it in double quotes ("). The interpreter reads all characters between the quotes. It also supports standard escaped characters, such as \n for a newline, as defined in its internal escape mapping.
2. Example: "Hello, world!\nThis is on a new line." pushes a single string value to the stack.
3. Literal Strings: For single words without spaces, you can use a more concise syntax by prefixing the word with a single quote ('). The interpreter's compile_atom logic identifies this pattern and pushes the word that follows (without the quote) as a string.
4. Example: 'hello is equivalent to "hello". It pushes the string "hello" to the stack.

3.3 Lists

Lists are ordered collections of other values. They can contain numbers, strings, and even other lists, allowing you to create nested data structures. A list is created by enclosing its elements in parentheses ( ... ). The interpreter's build_list function is responsible for parsing these structures.

Example: The code (1 two (3 4) five) will push a single list onto the stack. Note that the entire list is a single item on the stack. The resulting stack will be: [ [1, "two", [3, 4], "five"] ]

3.4 Code Blocks (Quotations)

A "quotation" is a block of code that is compiled but not immediately executed. Instead, the compiled function itself is pushed onto the stack. This is a powerful concept that is fundamental to control flow and creating higher-order functions. Quotations are defined by enclosing code in curly braces { ... }. Internally, the { word triggers the block function, which compiles all subsequent words until it finds a matching }.

Example: The code { 2 3 + } does not execute the addition. Instead, it pushes a single function onto the stack. This function, when later called, will perform the 2 3 + operation.

Now that we understand how to place data and even inert blocks of code onto the stack, we can explore how to give these code blocks names, creating reusable words.

4.0 Building Your Vocabulary: Defining New Words

The true power of this language lies in its extensibility. You can define new words, which are the equivalent of functions or subroutines in other languages. This allows you to build layers of abstraction, creating complex programs from simple, reusable components.

The primary mechanism for defining a new word is the colon syntax: : <word-name> ... ;.

When the interpreter encounters a colon (:), it performs the following steps, as seen in the w[':'] implementation:

1. It reads the next word from the source text and uses it as the name for the new definition.
2. It creates a new, lexically scoped environment for this word by calling make_env(env). This means the word will have its own private memory for local bindings.
3. It compiles all subsequent words into a single function, stopping when it encounters a semicolon (;).
4. It assigns this newly compiled function to the chosen name in the language's vocabulary.

Let's deconstruct the : show-verse definition from the example application to see this in practice.

: show-verse
  dup bind key
  bible key get-property
  ([ # ]) remove-characters p:
  h1:
;


* : show-verse ... ;: This defines a new word named show-verse.
* dup bind key: This line expects a verse key (e.g., "Genesis 1:1") to be on the stack. dup duplicates it, leaving the stack as ["Genesis 1:1", "Genesis 1:1"]. The bind key part consumes the top copy and creates a local binding named key within this word's private environment. The stack is now ["Genesis 1:1"].
* bible key get-property: This sequence demonstrates precise stack choreography. First, bible pushes the main data object. Then, key looks up its bound value and pushes it. The stack is now ["Genesis 1:1", {bible_object}, "Genesis 1:1"]. The get-property word consumes the top two items (the object and the property name) and pushes the result. The stack becomes ["Genesis 1:1", "In the beginning..."].
* ([ # ]) remove-characters p:: This takes the verse text, removes some special characters from it, and then calls p:, a writer word that sets the text content of our main paragraph element.
* h1:: This takes the original verse key (which has remained on the stack throughout the process) and uses it to set the text content of the main heading element.

The language also provides defun as an alternative syntax for defining words. It serves a similar purpose, associating a name with a reusable block of code.

Now that you can encapsulate logic into new words, the next step is to give those words decision-making capabilities.

5.0 Logic and Control Flow

To create dynamic and responsive programs, you need to control the flow of execution based on certain conditions. This section covers the language's structures for conditional logic, allowing your programs to make decisions based on the values on the stack.

5.1 Conditional Execution with if

The language uses an if ... then ... else ... end structure for branching logic. The if word compiles code that works as follows:

1. The code between if and then is executed first. This block is expected to leave a single boolean value (true or false) on the stack.
2. The if machinery consumes this boolean value.
3. If the value was true, the code in the then branch (between then and else or end) is executed.
4. If the value was false, the code in the optional else branch (between else and end) is executed. If there is no else branch, nothing happens.
5. The end word marks the completion of the conditional block.

Example: This code checks if the number 5 is greater than 0 and pushes the appropriate string.

5 0 > if
  then "The number is positive."
  else "The number is not positive."
end
log


The evaluation proceeds as follows: 5 0 > pushes true to the stack. The if word consumes true, so the code in the then branch is executed, which pushes the string "The number is positive." to the stack. Finally, log consumes this string and prints it to the console.

5.2 Multi-Way Branching with case

For situations with more than two possible outcomes, the case ... end structure provides a clean way to handle multi-way branching. It takes a value from the top of the stack and performs a strict equality check against a series of literal cases, which is evident from the obj[value] lookup in its implementation.

The case structure works by reading pairs of a match value and the code to execute. It executes the code associated with the first value that matches the value taken from the stack. An optional else clause can be provided as a default case if no other values match.

The Bible Verse Viewer application uses this structure perfectly to handle keyboard input:

event.key case
  (` ` r)                     random-verse
  (w a ArrowUp ArrowLeft)     previous-verse
  (s d ArrowDown ArrowRight)  next-verse
end


1. event.key pushes the name of the key that was pressed (e.g., "w") onto the stack.
2. case consumes this string.
3. It checks if the string is in the list (  r).
4. It checks if the string is in the list (w a ArrowUp ArrowLeft). If the user pressed "w", this is a match.
5. The corresponding word, previous-verse, is executed.
6. The case block finishes.

Control flow often involves managing application state. We'll now look at how the language stores information for longer-term use.

6.0 Managing State: Variables and Bindings

While the stack is perfect for the transient data used in calculations, most applications need to store information for longer-term use. Variables and bindings provide this persistence, allowing you to manage the application's state.

The primary word for creating a variable is declare. It reads the next word from your code and establishes it as a new variable in the current environment, initialized with a value of 0.

declare my-counter


To modify these variables, the language uses a family of mutator words. The internal mutator function is used to create words like set, get, increment, and decrement. These are special "immediate" words, meaning they execute at compile-time to generate code that will modify the variable at run-time.

A common pattern looks like this, adhering to the language's postfix syntax:

declare my-counter       --- Creates a variable named my-counter.

5 set my-counter         --- Pushes 5 to the stack. The 'set' word consumes
                           the value 5 and updates the 'my-counter' binding.

my-counter log           --- The word itself pushes the current value 
                           to the stack. 'log' consumes this value and
                           prints it to the console.


Advanced Binding and Lookup Syntax

The language also provides a special syntax using colons for more dynamic, run-time binding and lookup scenarios.

* :name (Delayed Binding): This compiles a function that, when run, will take the value from the top of the stack and bind it to the word name in the current run-time environment.
* :name: (Delayed Binding and Push): This does the same as :name but also leaves the value on the stack for further use.
* name: (Delayed Lookup): This compiles a function that will look up the value of name when the code is executed, not when it's compiled. This is useful when name might be defined later or in a different context.

With these fundamental concepts of data, logic, and state covered, it's time to explore the language's most powerful feature: its deep integration with the web browser.

7.0 Interacting with the Browser: The DOM API

This language is designed with modern web development in mind, providing a high-level, declarative API for creating and manipulating HTML elements, handling user events, and applying styles directly from your code.

7.1 Creating and Managing Elements

The primary tool for building your user interface is the dom word. It takes a single list from the stack and transforms it into an HTML element structure. The syntax is (tag-name [directives...]), where directives control the element's attributes, content, and behavior.

The following directives are available inside a dom list:

Directive Syntax	Purpose
(<nested-tag> ...)	Nests another element as a child.
.class-name	Adds a CSS class to the element.
#id-name	Assigns a unique ID to the element.
-attribute "value"	Sets an HTML attribute (e.g., -href "...").
:word-name	Binds the created DOM element to a new word.
@event-name ( ... )	Attaches an event listener.
text "some text"	Sets the text content of the element.
reader word property	Creates a word that reads a property from the element.
writer word property	Creates a word that writes a property to the element. This is a powerful feature for creating custom, declarative APIs to manipulate specific elements, as we will see in the case study.

Once an element is created with dom, you can add it to the page using helper words like to-body (appends to the document body) and append (appends to a specified parent element).

7.2 Handling User Events

The @event-name ( ... ) directive is the standard way to make your interface interactive. It wires a browser event (like click or keydown) directly to a block of code.

Let's deconstruct this line from the case study application: (button #left-button @click (previous-verse:))

* (button ...): Creates a <button> element.
* #left-button: Assigns it the ID left-button.
* @click: Specifies that we are attaching a listener for the click event.
* (previous-verse:): This is the code that will be executed when the button is clicked. The previous-verse: word is a delayed lookup, ensuring the most current definition of that word is called at runtime.

For more complex scenarios, the lower-level handler word can be used to capture the browser's full event object, as seen in the application's body 'keydown handler definition.

7.3 Styling with css

The language seamlessly integrates styling through the style word, which takes a list of CSS rules and applies them to the document. The internal css function translates a list-based syntax into standard CSS text. Each rule is a sub-list formatted as (selector (property value property value ...)).

This example from the application styles all <p> elements:

(p
  font-size 1.3em)


This is translated into the CSS: p { font-size: 1.3em; }

7.4 Asynchronous Operations

Modern web applications frequently need to perform asynchronous operations, like fetching data from a server, without freezing the user interface. The language handles this elegantly with the wait keyword.

When the interpreter sees wait, it switches its internal code generation from the standard make_sub function to make_async_sub. This alternate function is promise-aware. When it executes your code, if it finds a Promise on the top of the stack, it will automatically await its result before continuing.

This is used in conjunction with the fetch word, which is a simple wrapper around the browser's fetch API. Let's break down the data loading line from the case study:

'kjv.json fetch -json set bible

1. 'kjv.json fetch: Pushes the URL string and calls fetch, which performs the network request and returns a Promise, placing it on the stack.
2. -json: This is a method call that consumes the Promise from the stack and returns a new Promise that will resolve with the JSON-parsed data. This new promise is pushed back onto the stack.
3. Because wait was called earlier, the interpreter pauses and waits for this final promise to resolve.
4. set bible: Once the data arrives, it is placed on the stack. The set bible code consumes this data and stores it in the bible variable.

All the necessary building blocks are now in place. We can proceed to analyze a complete application from start to finish.

8.0 Case Study: Building the Bible Verse Viewer

This section is the culmination of our tutorial. We will now deconstruct the provided example application, connecting each piece of its code back to the concepts we have learned. This will solidify your understanding by showing how these simple parts combine to create a functional, interactive program.

8.1 The User Interface (UI) with dom

The application's entire HTML structure is defined in a single, declarative block.

(main
  (h1 writer h1 text-content)
  (p writer p text-content)
  (button #left-button @click (previous-verse:))
  (button #right-button @click (next-verse:))
  (button #bottom-button @click (random-verse:))
  (button #top-button @click (color-picker:))
) dom to-body


* A <main> element is created to contain everything.
* The (h1 writer h1 text-content) directive is particularly clever. It creates an <h1> element and uses the writer directive to define a new word, h1:, which acts as a function to set the textContent property of that specific h1 element. The same is done for the <p> element, creating p:.
* The first three <button> elements have their click events wired directly to the application's core logic words (previous-verse:, next-verse:, etc.).
* The final button, #top-button, is wired to the color-picker: word. This demonstrates dynamic UI generation: when clicked, color-picker: creates a new <section> element, appends it to the body, and then calls the fill-colors word to populate it with dozens of new, interactive color- swatch buttons.
* Finally, the entire structure is pushed to the stack by dom and appended to the page by to-body.

8.2 The Styling with style and css

The application's appearance is defined in a similar list-based structure passed to the style word.

((font-face fantaesque /fan.ttf)
 (body
   ...
   padding (7vh 14vw))
 ...
) style


* This block defines all the CSS for the page, including a custom @font-face rule.
* Notice how multi-part CSS values are naturally represented by nested lists, as seen in (padding (7vh 14vw)). This is translated directly to padding: 7vh 14vw;.

8.3 The Core Logic: Defining Words

The application's behavior is encapsulated in a few custom words.

: show-verse
  ...
;

: next-verse
  verses next-element
  show-verse
;
...


* We've already analyzed show-verse. It is the central word for updating the display.
* next-verse, previous-verse, and random-verse are simple words that first manipulate verses and then call show-verse to render the result. verses is an iterator object created by the iterator word, which wraps the list of verse keys. Words like next-element operate on this specific data structure, advancing its internal pointer (iterator.pointer++) before pushing the next element to the stack. This is an excellent example of building complex behavior by composing simpler words.

8.4 Data Loading and Initialization

The final block of code orchestrates the application's startup sequence.

"Loading the bible..." p:

wait

'kjv.json fetch -json set bible

bible keys iterator set verses

random-verse


The execution proceeds in a clear, logical order:

1. "Loading the bible..." p:: An initial message is immediately displayed to the user by calling the p: writer word we defined in the dom block.
2. wait: The interpreter is switched into asynchronous mode to handle the upcoming network request.
3. 'kjv.json fetch -json set bible: The bible data is fetched from the server, parsed as JSON, and stored in the bible variable. The program pauses here until the data is fully loaded.
4. bible keys iterator set verses: Once the data is loaded, the keys (verse references) are extracted and turned into an iterator data structure, which is stored in the verses variable. This structure will keep track of which verse is the "current" one.
5. random-verse: Finally, the random-verse word is called to select an initial verse and display it on the screen.

9.0 Conclusion and Next Steps

You have just journeyed through the core of a powerful and expressive stack-based language. We have seen how its simple, consistent architecture—built entirely around the stack—allows for a unique programming style. You've learned how to manipulate the stack, work with data, define your own vocabulary of words, and use its rich, integrated API to build a complete, data-driven web application.

From the fundamental dup and swap to the high-level dom and style words, every piece of the language is designed to work together cohesively. You have progressed from basic stack operations to understanding a non-trivial program, which is a testament to the language's learnability.

The best way to solidify your knowledge is to experiment. Try modifying the example application: change the styles, add new functionality, or load a different dataset. Then, challenge yourself to write a new program from scratch, using the concepts from this tutorial as your foundation. Welcome to a new way of thinking about code.

# oh

* A stack rpn language

```oh
1 2 +
```


It's a javascript file that you can download and run in browser or in node:

https://raw.githubusercontent.com/vms14/oh/refs/heads/main/oh.js

## Usage:

* In node it launches a read eval print loop that prints the contents of the stack

```bash
node oh.js
1 2 +
[ 3 ]
```

* In the browser it loads an executes <oh> tags after the document loads

```html
<!DOCTYPE html>
<html>
<head>
 <script src="https://vms14.github.io/oh.js"></script>
</head>
<body>
 <oh> (p "oh...") dom to-body </oh>
</body>
</html>
```
* If the tags have a src attribute it will fetch then and evaluate it

```html
<oh src="oh.oh"></oh>
```

* If a tag has both a src attribute and code inside it, the src file will get fetched and evaluated first, after that then the code inside the tag will be evaluated

```html
<oh src="oh.oh"> 1 2 + </oh>
```

## Explanation:

oh is a stack based language that assumes javascript functions are the bytecode.

It tries to unify everything by converting tokens into functions. Every token in the source code is an action that is represented in form of a function.

The process of turning tokens into functions is called compile time, although is not really compilation, but delayed execution.

Runtime is when those functions are being executed.

A word is a token registered in an environment in the form of a function.

The fake compiler looks up tokens in the chain of environments at compile time and returns the associated functions. If the token is not a registered word it will try to understand what it is, returning a function that performs an action or triggering an error.

Some words are immediate, which means they execute at compile time, if the compiler finds an immediate word, it will be executed by the compiler instead of being returned.

Some immediate words execute at compile time, but also return a function on the stack. When the compiler finds one of those words it executes it and returns the function that word puts on the stack after being executed.

Those immediate words extend the compiler.

Environments exist at compile time and by default at runtime there are no environments except for the root environment. Environments are mainly for compile time word lookup, at runtime everything is a collection of functions that will get executed, so there is no real need for lookup at runtime.

Some immediate words return functions to the compiler that will create an environment at runtime and evaluate the code inside that environment, those words are block, lambda and defun. The rest of the interpreter works under the assumption that there are no environments at runtime and that they are just disposable compile time lookup chains.

A number gets converted to a javascript closure that captures that value in a js lexical variable and pushes it on the stack when executed.

The compiler when it finds a string that matches a number regular expression, will generate and return such function.

Runtime will be to call that function, which will push the number on the stack

```oh
1 2 3
```

gets converted into 3 closures in javascript that capture those numbers.

All the code gets compiled by converting it into functions and collected into an array. Then that array gets iterated and all the functions executed.

Some words like ":" are immediate and read from the source code to implement new syntax:

```oh
: oh 1 2 3 ;
```

That will define at compile time a word named "oh" in the root environment which internally will be an array of 3 closures, every one of them capturing a number and pushing it on the stack when executed.

evaluating oh is to iterate that array and call those functions.

The interpreter just cares about turning everything into a function or executing immediate words at compile time, some immediate words can return a function on the stack that the interpreter will get and return as if it were generated by itself.





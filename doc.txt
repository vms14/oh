I'm going to lay down everything i know and think about this interpreter.

I will focus on explaining everything as much as possible from all different aspects of the language.

What i think, what i know, why exists, how it works, etc.

But there will be no particular order and all thoughts will be scattered, so it is a raw brain dump.


### What this language is?

It is a rpn stack based language written in javascript.

It tries to rely as much as possible on javascript, to provide as much as interoperation with it as possible.

The main goal is to inherit access to all the browser APIs and do everything js can do but in a weirder way.

It is also my playground to experiment with programming.

In a way it is a reflection of my current understanding about programming. Everything i know about programming is being reflected either as part of the core interpreter or as a word definition.

It grows when my understanding grows.

When my understanding grows and the current implementation does not match my understanding anymore, it gets rewritten from the scratch.

But it also amplifies my understanding.

It is a playground for my mind and a training process to teach me about almost any concept about programming.

I can test any idea without friction, integrate it to the language, combine it, drop it or evolve it.

While showing this interpreter to chatgpt and discussing about it, it told me that it's not really reflecting my understanding, but how i deal with uncertainty and that also mirrors my own learning procedure.

That in a way, it mirrors how i think.

For me this interpreter is just a playground for ideas.

An idea can be tested immediately by just creating a word definition, either in the language itself or in javascript.

New syntax can be added by just creating a function that reads the source code and returns another function that will perform the logic, or performs the logic right away.

The language does not care about almost anything.

It only cares about reading a token and turning it into a function.

Some tokens provoke arbitrary execution of code while the rest are delayed and stored as functions.

The interpreter just reads tokens and collects functions, which will be iterated and called in sequence later.

If for example it reads a number like "1", it will create a closure in javascript that stores that number and when executed will push it on the stack.

1 becomes in a way:

```js
let value = 1; return () => stack.push(value)
```

So the interpreter just reads a number and captures it, returning a function, that will get executed later.

I call the process of generating functions the compile procedure or compile time, and I see the execution of those functions as the runtime of the interpreter.

It is not compiling anything, but delaying executions and precomputing decisions.

The goal of the compiling procedure is to avoid as much as possible runtime overhead, mainly runtime lookups.

It is not the same to lookup what a word means once, than 200 times in a loop.

Although performance is not the real reason the compiling procedure actually exists.

The main reason is to freeze definitions so when a definition relies on another definition and gets "compiled", if the other definition gets redefined, this defintion that used the other one will not be affected by the other definition being updated.

In other words, it avoids dynamic binding.

All the words are found in an environment in the form of a function. An environment is just:

```js
{ parent: pointer_to_another_environment_or_undef, word: {} }
```

The compiling procedure just searches for the chain of environments and looks whether the token is found in the word: {} object that serves as a lookup table for words. All words are stored in that word: {} object, the interpreter just finds and returns them.

When we are creating a definition, we are just reading tokens, turning them into functions, then storing those functions in an array.

The colon word is the main interface for the language to create a new definition.

It reads the name of the word that is going to be generated in the current environment and starts gathering functions and storing them into an array.

For example the definition of a word that pushes three numbers on the stack when executed:

```oh
: push-three-numbers 1 2 3 ;
```

The colon word ":" is an immediate word.

An immediate word executes at compile time.

The main procedure to turn a token into a function is a javascript function named compile element

compile element takes one argument and tries to return a function. It tries to unify everything into a function.

A token in the language will always represent an action.

This action gets represented internally by a function.

A number becomes a function that will push the number on the stack.

A word defined in the environment is just a javascript function.

A primitive word is a word defined in javascript directly like:

```js
env.word.name = () => console.log("hi i am the word named 'name'")
```

env is the current environment pointer. It is where compile element starts searching for words.

When compile element is given the argument: "name" like in: compile_element("name") in js

It will start looking from the environment pointer:

```js
 if (env.word.name)
 {
   return env.word.name
 }
```

In this case if we defined that env.word.name, it will be a javascript function, compile element will just return that function.

compile element is the whole interpreter.

It only cares turning everything into a function or excuting immediate words.

There are two types of immediate words.

What i call immediate 0 and immediate 1

The 0 or 1 is just a flag compile element uses to distinguish between those two types.

immediate 0 means "execute this right now"

immediate 1 means "execute this right now, it will return a function on the stack which you will pop from the stack and return to the caller"

If a word is immediate it will execute it, if it's immediate 0, compile element will return undefined, if it's immediate 1, that word when executed will push a function on the stack and compile element will return it

If the token does not map to a word, compile element will fallback to compile atom, compile atom tries to provide syntax sugar for literals and fancy stuff.

A token is what read word returns, read word just reads the source code until a space, newline or tab, and returns the token it has read.

Some characters are special for read word, they do not require spaces between them and constitute an entire token by themselves.

The special characters are ( ) [ ] { } ` and "

This is because those characters are used for special syntax provided in the form of immediate words.

The starting delimiters like "(" "[" and "{", are immediate words that execute at compile time and start reading from the source code, to implement a different syntax. The closing delimiters ")" "]" and "}" are just a sentinel character for those reader words. Those immediate words will read until they find in the source code the closing delimiter.

"(" "[" and "{" just call the read word function to retrieve a word and do something with it. The read word function knows both the starting and closing delimiters are special characters, so when it finds one of them it will return it without expecting spaces betwen them.

That means that for the interpreter, reading

```oh
"(1 2 3)"
```

is equivalent to reading

```oh
 ( 1 2 3 )
```

The simplest example is "(" which is an immediate 1 word. Being an immediate word means compile element will execute it when it receives the "(" token as its argument, and being immediate 1 means this word has to push a function on the stack, which compile element will take and return to the caller.

The read eval print loop in node will just read a line of source code and make this to become the source of the interpreter,

Then it will call read word and give whatever read word returns as the argument to compile element.

Compile element will either return undef or a function. The repl will store that function into an array.

After all the source code has been exhausted, the repl will iterate through this array and call all the functions compile element returned.

If we were to type something in the repl like:

```oh
1 2 3
```

The repl will set the source to be the string "1 2 3", then create an empty array, then start calling read word until read word returns undefined, meaning the source is exhausted, giving whatever read word returns to compile element and if compile element returns a function, it will get appended to that array, After read word signals end of source code by returning undefined, the repl will take this array and iterate it, calling all the functions.

In this case what it would do is to call compile element three times

```js
compile_element("1")
compile_element("2")
compile_element("3")
```

Compile element will search in the environments starting from the current environment, fail because there is no word defined 1, 2 or 3 in any environment, then fallback to compile atom.

Compile atom only applies several regular expression checks on that atom to determine what it is.

In the case of 1 2 and 3, they match the number_regex regular expression which is:

```js
const number_regex = /^-?\d+(\.?\d*)$/
```

And it will return a function that will push that number on the stack:

```js
if (atom.match(number_regex))
{
  const number = parseFloat(atom)
  return () => put(number)
}
```

So compile element will return those closures for those numbers and the repl will store them into an array

Similar in a way to this, but the numbers are lexical js variables instead of the literal numbers:

```js
[() => put(1), () => put(2), () => put(3)]
```

That's what the repl will generate from reading the line of input "1 2 3"

Then it will just iterate this array and call all those functions in order.

That moment is what i call runtime, the execution of the collected functions.

Compile time is just when we are generating them, when we call compile_element(read_word()) and gather the results into an array.

If we are gathering functions into an array, and we give compile_element the name of an immediate 0 word, compile_element will return nothing, it will just evaluate that word right away, and we won't get anything to push on our array.

If we instead give it the name of an immediate 1 word, compile element will execute that word, the word will generate a function and return it on the stack, compile element will return us that function and we will append it to our array

This is all the interpreter does, the rest is just to create words, either normal words, immediate 0 or immediate 1 words and maybe extend compile atom with more regular expressions.

The interpreter does not know what syntax is, syntax is just tokens separated by spaces, newlines or tabs, and some characters that are a token by themselves.

It does not know what an if statement is, what a loop is, etc. It just knows there are environments which store words, those words are either returned or executed and some words might return a compilation unit in form of a function when executed. Plus the compile atom function which is just a bunch of regular expressions.

If compile atom runs all the chain of checks on this atom and does not recognize it, it will trigger an error.

New syntax not integrated in compile atom as a regular expression is implemented by immediate words that execute at compile time, read the source code either by characters or by calling read_word and perform logic at compile time, add entries into the compilation time environments, and/or return a function on the stack that will get inserted to the compilation array.

The "(" is the simplest example of an immediate 1 word that implements new syntax and returns a function on the stack that will get appended to our compilation array.

The "(" internally calls a js function named build_list, that creates an array and calls read word until read word returns the ")" token.

```oh
(1 2 3)
```

If we were to type this in the node repl, the repl will call read word and read word will return "("

Note that "(" does not require spaces and read_word returns "(" alone instead of "(1" because "( ) [ ] { }" are special characters that read word returns when it finds them without expecting any space.

So for the interpreter this will always be seen as if we type: " ( 1 2 3 ) "

Then the repl calls compile_element("(") and compile element finds this word in the root environment and sees that is an immediate 1 word, so it executes it and expects it to return a function on the stack, which will return to the repl and the repl will store in the array of functions is generating.

the "(" word will execute and will start calling read word until read word returns ")", it will just store all those results into an array.

This is an aproximation of what it does when compile element calls it:

```js
const list = []
let word
while ((word = read_word()) !== ")")
{
  list.push(word)
}
stack.push(() => put(list.slice())
// list.slice() is a js idiom to copy a list, similar to the spread operator [...list]
// but the spread operator chokes with really long lists in v8 at least because it's recursive while slice is not
```

* The closure returns a new copy of the list 
instead of the original one to avoid mutation of that list, so every time you execute the closure that "(" generated, it will return a fresh copy of the list that was been built at compile time.

When "(" receives the ")" token from read word, it stops reading words and generates a javascript closure that when executed will push that array on the stack, then it just pushes this closure on the stack, compile element takes this closure and returns it to the repl and the repl stores it into the array of functions it is gathering. Once the repl knows there is no more input to compile, it will run the functions in this array. In this case the array will contain:

```js
[() => put(list.slice())]

```

And it will just iterate it and call that function.

That function is the closure the "(" word generated from reading words and pushed on the stack at compile time.

That's how syntax, control operators, loops, etc is added into the language.

The language does not know what "(" does more than that "it executes and returns something at compile time"

The "(" extends compile element in a way, since compile element trusts this word to generate a compilation unit.

I like how the language does not care about anything, yet it can be extended almost infinitely by immediate words.

For example the interpreter does not know what "if" means, except that "if" is an immediate 1 word.

the "if" word will read the source code and generate a closure that when executed, will perform the logic of the "if" statement.

Everything in this language is mainly delayed execution and partial evaluation.

I tried my best into unifying everything into a function. Including variables.

Variables do not exist in this language, the word bind creates something that acts as a dynamic variable, but it's just a closure that pushes a value on the stack and this value can be mutated.

The reason i say i tried to unify even variables into a function is because bind generates a function that behaves as a variable.

The function is just this:

```js
const binding = () => put(binding.value)
```

It relies on the fact that javascript functions are objects to just store the value property on the function object itself, making that closure become a cell or storage unit that when executed will push that value on the stack.

In order to mutate a value we just need a reference to that function and do something like:

```js
binding.value = 3
```

And now when executed this function will push the number 3 on the stack.


That means that everything that stores a reference of that function is also storing a way to access and mutate this value.

It also implies that this binding is dynamic, if you mutate the value, everything that has a reference to that function will see the effects, since the function just pushes that value on the stack when executed, the value will be whatever value it has the moment this function gets executed, so the value will always be the last value being set.

The environments are cool.

Any definition that starts reading words and compiling them by calling compile atom and read word, will likely create a new environment before doing anything, and set this new environment as the current environment by overriding the env pointer, which is a global pointer used by the interpreter to point to whatever the current environment is and gets overwritten several times during compilation to always point to the current compilation environment. After a definition has been compiled, the current environment pointer will point back to the previous environment. Every definition that messes with the current environment pointer will store a reference to what it was pointing to and later restore it to point back to that reference.

The main example of a definition is the colon word, which is an immediate 0 word:

```js
env.word[":"] = () =>
{
  const name = read_word()
  const code = []
  const old_environment_pointer = env
  env = make_env(env)
  let word
  while ((word = read_word()) !== ';')
  {
    const value = compile_element(word)
    if (value)
    {
      code.push(value)
    }
  }
  env = old_environment_pointer
  env.word[name] = () => { for (let fun of code) { fun() }}
}
env.word[":"].immediate = 0
```

That's mainly what the ":" word does, although it internally uses a function that performs this behavior, since it's a common pattern for any word that creates a definition.

The colon word executes at compile time, it's an immediate 0 word, so compile element executes it and returns undefined, because immediate 0 words just execute at compile time, but do not need to return any function on the stack, since they are mainly executed to perform some sort of side effect.

In the case of the colon word, the side effect is to generate a new word definition in the current environment.

The current environment when the interpreter starts, points to the root environment, which is an environment that has no parent:

```js
let env = { parent: undefined, word: {} }
const root = env
```

root is just a pointer to the first environment ever created, which is the root environment.

When we type in the repl:

```oh
: some-word-name 1 2 3 ;
```

The repl calls compile_element(":") and compile element finds ":" which is defined in the root environment and is an immediate 0 word.

Then the function stored in root.word[":"] is executed

This function stores a reference of whatever "env" was pointing to, then creates a new environment and overrides "env" to point to it, so now compile element will start searching words there, this environment inherits from whatever was the current environment when ":" gets executed at compile time.

Since it's a top level definition, the environment created will be a child of the root environment, and now the current environment will be this one.

Then it will start compiling 1, 2 and 3, until it reads the semicolon that signals the end of this definition.

Then it restores the current environment pointer to point back to the root environment and registers this definition into the root environment since it was the current environment when ":" was executed.

Now the root environment is:

```js
root = { parent: undefined, word { 'some-word-name': () => { for (let fun of code) { fun() }} } }
```

The environment that was generated by the colon word has been lost and garbage collected by javascript, since that environment was only temporarily referenced by the current environment pointer, but once the colon word ends compiling, the current environment pointer now points to the root environment again and no one has stored a reference to that new environment, so js schedules that environment to get collected for the gc.

That means that the environments that are created in definitions exist only during the compile time of that definition, they inherit from whatever environment was the current environment at the time of that definition and they get destroyed after the definition ends.

It is lexical scope at compile time.

A definition can be created inside another definition. It will generate a new environment that inherits from the parent, then compile stuff, then restore the environment pointer to point to the previous one. If that definition gets inserted into the previous environment, the outer definition will find it because it will call compile element and compile element will see that word registered in the environment.

The colon word creates definitions at compile time and injects them into whatever was the current environment at that point.

Note that in our some-word-name example, we were typing this into the repl and the repl called compile element to evaluate ":" at compile time, since ":" is an immediate 0 word, which means that just executes and returns nothing, compile element returned undefined and the repl did not append any function on its compilation array, since the repl just calls compile element until the source code is exhausted, then stores those functions in an array, and after there is no more input it iterates this array, calling each function in sequence.

The repl and a definition of a word are similar in the way that they collect functions into an array and their execution is just to run those functions in sequence later.

In the case of the line that only contains a definition like ": some-word-name 1 2 3 ;" the repl calls read word, read word returns ":" and the repl gives that to compile element, compile element executes ":" and returns undefined, so the compilation array of the repl is empty.

If the line were instead

```oh
: some-word name 1 2 3 ; some-word-name
```

The repl will call compile element with ":" as before, ":" will read words until it finds the ";" semicolon, then compile element will return nothing, the repl will call read word again and this time read word returns the string "some-word-name" which the repl gives to compile element and since ":" has registered this word in the root environment, compile element finds it and returns it to the repl, so the compile array of the repl contains the javascript function that ":" created:

```js
const the_repl_execution_array = [() => { for (let fun of code) { fun() } }]
```

and the repl will keep gathering functions until read word signals eof by returning undefined.

Then the repl will iterate that array and call all the functions.

```js
for (let fun of the_repl_execution_array)
{
  fun()
}
```

Which is exactly the same kind of function the colon word and any other definition generates.

Just note that when compile element returns undefined, which is when an immediate 0 gets executed, nothing is pushed in those arrays.

And when an immediate 1 gets executed, the function that immediate word returns on the stack gets appended to those arrays.

If the repl had the line ": some-word-name 1 2 3 ;"

The word definition will be like:

```js
env.word['some-word-name'] = () => { for (let fun of [() => put(1), () => put(2), () => put(3)]) { fun() } }
```

And the repl execution array will be empty, since it only has read ":", compile element returned nothing because ":" is immediate 0, so the repl did not append anything, then the repl calls read word again, but read word returns undefined too, because the line had no more input and the ":" word has exhausted the input itself, reading until a terminating semicolon ";".

That means that if a ":" is found inside the code of an outer colon definition, the outer ":" will call compile element with the ":" argument, which makes this process recursive, meaning that any immediate word that calls compile element will recurse if the argument it gives to it is the name of that immediate word itself, since compile element will just find that this word is immediate and execute it.

That's how or why colon definitions can be nested:

```oh
: outer-definition
  : inner-definition 1 2 3 ;
;
```

* Just as a note, the node repl only reads by lines so it would choke on this code being separated by newlines, in the node repl would have to be one line: ": outer-definition : inner-definition 1 2 3 ; ;" This is a strong limitation of the node repl. Note also that if we were loading an entire file, either from node or the browser, we would be creating an array of functions and read and compile all the words in the entire file, storing all the functions in the array, then after we find the end of the file, we will iterate this array and execute all the functions, mirroring what the repl does for a line and what the colon word does for a definition.

When whatever was reading the source code (the repl, the procedure that loads a file, the oh tags in the browser, etc), finds the first ":" and feeds it to compile element, the ":" word executes and starts creating a definition named "outer-definition", for this definition it creates a new environment that inherits from the current environment (in this case the root environment) and starts compiling words, by calling read word and giving that word to compile element.

The ":" word reads the word "outer-definition" and sets it as the name for the word:

```js
const name = read_word()
// name = 'outer-definition'
```

Then stores a reference of whatever was the current environment

```js
const previous_environment = env
// previous_environment = root
```

Then creates a new environment that will inherit from the current environment, and makes this environment become the current one.

```js
env = make_env(env)
```

So now env is a temporary environment that the ":" has generated and inherits from the root environment, since make_env returns:

```js
{ parent: root, word: {} }
```

This can be considered the environment of the "outer-definition" word, since it is generated to become the current environment for the compilation of that word.

Then the ":" word starts reading words until it finds a terminating semicolon ";"

```js
const code = []
while ((word = read_word()) !== ";")
{
   const value = compile_element(word)
   if (value)
   {
     code.push(value)
   }
}
```

* Note that this loop will call compile element every time until a ";", but the environment in which compile element will start looking for definitions is that environment ":" has generated for that current definition, the environment of the word "outer-definition".

Then it will read the next word and find another ":", which compile_element will execute since it's an immediate 0 word, and return undefined after executing it.

The ":" word then will recurse since it's calling compile element and compile element is calling ":" and the same process will repeat.

The ":" word will read the next word, which is "inner-definition" and say:

```js
const name = 'inner-definition'
```

then do the same thing with the environments, store a reference to the current environment and set the current environment to a new environment that inherits from the previous one:

```js
const old_environment = env
env = make_env(env)
// env = { parent: the_environment_of_outer_definition, word: {} }
```

Now the current environment is an environment that inherits from the environment of the "outer-definition" word, and a pointer to the environment of the "outer-definition" word is stored as the "old_environment" reference, to later restore "env" to point there again after it finds the semicolon ";".

then the inner ":" will keep reading words in our example it was ": inner-definition 1 2 3 ;" so it will call compile element with those numbers and create an array like:

```js
const code = [() => put(1), () => put(2), () => put(3)]
```

Then restore the "env" pointer to point back to the previous environment:

```js
env = old_environment
// env = the_environment_of_the_outer_definition
```

And register the word in that current environment.

```js
env.word[name] = () => { for (let fun of code) { fun() } }
// env = outer_definition_environment
```

Then it ends execution and the outer ":" definiton resumes from there.

In this case the outer definition had no code inside it.

```oh
: outer-definition
  : inner-definition 1 2 3 ;
;
```

The outer ":" only has read the name of the word to define, then it found a ":" inside it, so compile element executed that while the outer ":" was executed, and returned undefined to the outer ":", so the code array of "outer-definition" would be empty and it's runtime execution would be to iterate through an empty array.

Also note that both the compile time environments that both ":" generated do not exist anymore, since when a ":" finds a ";" and terminates compilation, it restores the pointer of the current environment to point back to the previous one and those environments do not get referenced by anything so javascript garbage collector frees them.

In this example it means that the inner definition was useless, since it was only visible during the compilation of the outer definition, but the outer definition didn't have more code except for the inner definition itself. Nothing has captured or frozen the inner definition and both environments of those words have been lost, so the function that inner definition generated has been lost.

It also means that outer-definition is a "do nothing" operation, because it's execution array is empty, since in it's code there was only an immediate 0 word that didn't return anything.

If the code were to be like this instead:

```js
: outer-definition
  : inner-definition 1 2 3 ;
  inner-definition
;
```

Then the same procedure would apply, but after the inner definition ends execution and injects the generated definition into the environment of the outer definition, the outer definition keeps reading words and it finds the word "inner-definition" in it's code, which gives to compile element and compile element finds it, because the current environment is the environment of the outer definition and the inner definition was defined in that environment, so it gets appended to the compilation array of the outer definition.

That's when the inner-definition gets frozen into the definition of the outer and even if the environments of inner definition and outer definition disappear, the outer definition gets defined in the root environment and the inner definition gets frozen as a closure in the code array of the outer definition.

```js
root.word['inner-definition'] = [() => { this is a stored reference of outer_definition_env.word['inner-definition'] }]
```

even if outer_definition_env and inner_definition_env (that env = make_env(env) both ":" generated at compile time) do not exist anymore, the function that the inner definition injected into the outer definition environment has been stored into the array of code of the outer definition word and the outer definition is itself available in the root environment.

Every definition that does

```js
old_environment = env
env = make_env(env)
```

will also restore that pointer later when it ends compilation with

```js
env = old_environment
```

That means that the first ":" stores a pointer to the root environment and the inner ":" stores a pointer to the environment the outer one generated, then later restores env to point back to that environment so when the inner ":" ends compilation, restores env to point back to the environment that the first ":" generated and when the first ":" ends compilation will restore env to point to the root environment.

At the end, no matter how much we nest definitions, we will come back to the root environment after compiling everything.

Unless this procedure fails to restore properly the current environment pointer which will likely become a problem.

If the interpreter finds an error, it will restore env to point back to the current environment.

An error throws a javascript error, the repl will keep evaluating, but reading from files or any other way will abort and stop reading.

If an error is found at compile time while we are messing with the environments, it will lead to an unknown state, by default all the interpreter will just abort, but if we were to continue like in a repl, the compiling procedure will fail to restore the env pointer, so an error will always point to root again, which only affects the repl because reading a file or a tag would abort all evaluation and compiling anyways.

An error in the interpreter is only triggered when something tries to retrieve on the stack more elements than the stack has and when a word is not recognized at compile time.

Some words will trigger an error by themselves, for example when an immediate word reads from the source code expecting a word and read word returns undefined.

The "(" word for example will trigger an error telling it did not find a terminating ")" if read_word returns undefined when "(" was expecting to stop reading words when read_word returns ")", since read word returning undefined means the end of source code, the "(" word understands that there is no more code to read and it never found a closing parenthesis ")".

Same for any word that expects a delimiter to stop reading words and any word that expects a word name in the source code.

For example the word "bind" reads a name from the source code and creates a word that associates a value from the stack with a name.

```oh
24 bind twenty-four
```

The bind word will read the word twenty-four and create a word in the current environment at compile time that will push 24 on the stack.

bind is an immediate 1 word, which means that not only executes at compile time (compile element executes it instead of returning it), but also returns a function on the stack at compile time that will get appended to the execution array of whatever we were compiling (compile element just executes bind and knows bind will return a function on the stack which will return to the caller, be it the repl itself, a colon definition, etc)

bind is immediate 1 because it has to operate at compile time, since it needs to read a word name and create an entry on the current compilation environment with that name so it becomes available after bind registers it and can later be used.

After executing bind, the word "twenty-four" will be available for that compilation unit, be it the line of the repl, the whole file, etc.

In this case we are using it inside any definition so it runs in the top level. The top level is the repl execution array, the file execution array, etc.

So if we later type "twenty-four" the repl or whatever will call compile element and compile element will find twenty four in the current environment (in this case the root environment)

And twenty-four should push the number 24 on the stack when executed.

The problem is, the number 24 must come from the stack, since the job of the bind word is to associate names with word values, to avoid stack juggling, but the bind word executes at compile time.

The binding the bind word generates is that function that acted as a cell

```js
const binding = () => put(binding.value)
```

It's a function that pushes a value that it's stored in itself, since functions in javascript are objects and binding.value is the value property of the function being generated.

In order to set the binding.value property to the value of the stack it has to delay the assignment to the runtime, this is why bind is an immediate 1 word that returns a function on the stack which compile element returns to the caller, because the function it returns is the setter.

The bind word does this when compile element executes it:

```js
const name = read_word()
// name = "twenty-four"
const binding = () => put(binding.value)
binding.value = 0
env.word[name] = binding
stack.push(() => binding.value = stack.pop())
```

Then compile element receives that function from the stack:

```js
() => binding.value = stack.pop()
```

And returns it to the caller, if we were on the repl, the caller would be the repl itself and this function would be appended to the repl_execution_array, which will later execute.

So the line in the repl:

```oh
24 bind twenty-four
```

will make the repl call compile_element("24") which will return that closure compile atom generates similar to: () => put(24) but 24 being actually a lexical js variable, result of parseFloat("24"), which the repl will append to its own execution array:

```js
repl_execution_array = [() => put(24)]
```

Then the repl will read the next word and give it to compile element:

```js
compile_element("bind")
```

And compile element will see it's an immediate 1 word, which has to execute and return a function on the stack:

the bind word calls read word and reads "twenty-four", then define an entry in the root environment with that binding, then push the setter (the () => binding.value = stack.pop()) on the stack and compile element will return that function to the repl, which the repl will add to it's own execution array:

```js
repl_execution_array = [() => stack.push(24), () => binding.value = stack.pop()]
// the code was: 24 bind twenty-four
```

The repl will find no more code to read so it will just iterate that array and execute each function.

The first function is just the number 24 converted to a function that pushes it on the stack when evaluated, so the repl will execute it and the stack will have that number on top.

The second function is the setter that bind returned on the stack, it takes an element from the stack and stores it to binding.value.

If we later were to use the word twenty-four, it will push whatever binding.value holds.

Let's try with a colon definition that creates a binding to use it later in a very complex operation:

```oh
: complex-operation bind number
   number 1 +
;
```

The word complex-operation creates a binding to associate the name "number" to a value from the stack, to use that name later to refer to that value, then it uses that binding to push that value on the stack, then it pushes 1 on the stack and calls the word "+" which will take those two numbers and sum them to return the result on the stack.

* Note that complex-operation does not really need bind here, but it's the simplest example to demonstrate what bind does. complex-operation could just be defined as: ": complex-operation 1 + ;"

In this case the top level (the repl or whatever, although the repl cannot really read multiple lines) will call read word which returns ":" and call compile_element(":") which will start a definition.

The ":" word will do that thingy with the environments, read the word "complex-operation", then start storing functions into its compilation array.

The first word in the definition of complex-operation is the word "bind", which being an immediate 1 word will execute at the compilation time of the complex operation, note that at this time the current environment points to the environment the ":" word has generated for the compilation of the complex operation (env = make_env(env)).

The word bind executes and reads the word "number" and creates that binding function

```js
const binding = () => put(binding.value)
```

And registers it to the current environment at that compile time:

```js
const name = read_word()
// name = "number"
env.word[name] = binding
```

then returns on the stack the setter function:

```js
stack.push(() => binding.value = stack.pop())
```

which the compile element function will take from the stack and return to its caller, being the caller the ":" word that its gathering functions for the code array of the complex operation, so the code array of complex operation is:

```js
code = [() => binding.value = stack.pop()]
```

But also the binding has been registered in the environment of the complex operation when bind did:

```js
env.word.number = binding
```

Then the ":" word will keep reading words, remember that the definition was:

```oh
: complex-operation bind number
   number 1 +
;
```

So after the word bind, the word number is found and compiled, compile_element("number") returns the word that bind has just registered in the current environment and ":" appends it to the execution array of the complex operation:

```js
code = [() => binding.value = stack.pop(), () => put(binding.value)]
```

then it reads the 1 which gets converted to () => put(1) by compile atom and the ":" word appends to the code array

```js
code = [() => binding.value = stack.pop(), () => put(binding.value), () => put(1)]
```

then it reads the word "+" which is defined in the root environment as:

```js
root.word['+'] = () => { const [one, two] = stack.splice(-2); put(one + two) }
```

in a way, the complex-operation word which was defined like:

```oh
: complex-operation bind number
   number 1 +
;
```

Is internally represented by the interpreter as:

```js
root.word["complex-operation"] = () =>
{
  for (let fun of [() => binding.value = stack.pop(), () => put(binding.value), () => put(1), () => { const [one, two] = stack.splice(-2); put(one + two) } ])
  {
     fun()
  }
}
```

If we try to use that word:

```oh
24 complex-operation
```

The repl or whatever will evaluate the number 24, which will get pushed on the stack, then evaluate the complex-operation word, which will iterate over that array.

```js
[() => binding.value = stack.pop(),
 () => put(binding.value),
 () => put(1),
 () => { const [one, two] = stack.splice(-2); put(one + two) } ]
```

The first function is the setter that bind returned on the stack when compiling, it will take that 24 from the stack and set it to the value of the binding:

```js
binding.value = 24
```

The second just pushes the binding.value on the stack, in this case just returning the number again:

```js
put(binding.value)
```

Then push 1 on the stack:

```js
put(1)
```

Then take two elements from the stack and sum them:

```js
const [one, two] = stack.splice(-2)
put(one + two)
```

And that's all.

The bind word just creates a binding at compile time, registering the word in the environment and appends the setter to the execution code to be executed at runtime.

At compile time the binding can be found even if binding.value has not been set yet (bind initially sets it to 0 anyways) and when the word bind creates in the environment gets executed, will push whatever binding.value is at that time.

Since bind creates the binding and injects the setter into the compilation array, when that code later executes will always set the value to an element from the stack, but the binding is available during the compilation process, since it's just a function pointing to it's own property and this property will get set later, whenever this function executes the setter will have been already executed.

In that example:

```oh
24 complex-operation
```

The complex-operation could refer to the word named "number" at compile time even if the "number" is just put(binding.value) and binding.value is not being set until runtime, because "number" is just a function that bind creates in the environment of complex-operation, then that function gets stored in the code array of complex-operation.

in the complex operation array the first function is the setter, so the first thing complex-operation will always do is to take a value from the stack and set that binding.value to whatever came from the stack. Then whenever the "number" word is used inside it's definition will just be the binding function that pushes that value on the stack again.

* Note that bind creates a dynamic binding and that sometimes is not desirable

The word bind can create multiple bindings at once if given a list instead of a name

```oh
1 2 3 bind (one two three)
```

Now we have three words that are bound to their respective values and we can use them:

```oh
one
two
three
```

And we will have [1, 2, 3] on the stack

What bind does since it's an immediate 1 word which means it has to execute at compile time and also return a function, is similar to what it does with one name, but instead of creating one binding and word in the current environment, it creates multiple.

When the repl hits the word "bind" and gives it to compile element, compile element calls it and expects a function to be on the stack after its evaluation, which will return to the repl so the repl adds it to its own compilation array.

The word bind reads a word from the source code by calling read_word, which in this case has returned the word "(".

The word bind checks if the word returned by read word is "(" instead of any other number and calls the build_list function, which is what internally the "(" word actually uses to read until a terminating ")" and returns the generated list.

That means that at compile time, when bind reads a name and the name turns to be an opening parenthesis, it will take this to understand you are giving it a list of names and call build_list, which will start reading until the closing parenthesis and return a list.

Then bind iterates that list to generate the bindings, for every name in the list it generates a binding function

```js
const binding = () => put(binding.value)
```

and an entry in the current environment

```js
env.word[name] = binding
```

In the case of

```oh
1 2 3 bind (one two three)
```

The bind word will receive the list ['one', 'two', 'three'] and iterate them, creating a binding function and an entry in the environment for every name:

```js
const list_of_names = build_list()
const bindings = []

for (let name of list_of_names)
{
  const binding = () => put(binding.value)
  bindings.push(binding)
  env.word[name] = binding
}
```

Then it has to return the setter on the stack so compile element takes it and gives it to the repl and the repl will collect it for its own array execution.

The function it returns is like:

```js
function ()
{
  const values = stack.splice(-list_of_names.length)
  // retrieves the same number of values than names were in the list
  for (let i = 0; i < list_of_names; i++)
  {
    bindings[list_of_names[i]].value = values[i]
  }
}
```

That's the setter that bind puts on the stack for compile element to give to its caller.

The repl will take that and append it to its own execution array.

The code:

```oh
1 2 3 bind (one two three) 
```

In the repl execution array gets "compiled" as:

```js
[() => put(1),
 () => put(2),
 () => put(3),
 () => { this is the setter bind has generated, const values = ...; for (let i...) { bindings[...]...} }] 
```

It is the same principle as with only one name, the only difference is that it generates multiple bindings and the setter gets multiple values from the stack and sets those bindings.

In a way bind is a hack to provide what could be seen as a variable, it has to be immediate 1 because it needs to delay the setter until runtime, since the values come from the stack at runtime.

If bind were not immediate, it could not generate the entry in the environment so the bindings it generates wouldn't exist after compile time, at runtime when bind executes. So it has to be immediate to be able to inject bindings at compile time.

The only purpose of bind is to help you associate values with names, to avoid stack juggling.

There are words to reorder elements from the stack, swap being the simplest one that just switches the position of the two top stack elements.

```oh
1 2
swap
```

The stack is [1, 2] after executing the functions 1 and 2 generated

Then swap executes and switches their positions, so now the stack is [2, 1]

This word is common in stack based languages and even with bind it is convenient.

The word "dup" creates a copy of the top element from the stack

```oh
1 dup
```

That will push 1, then dup will duplicate it so the stack is [1, 1]

With bind we can avoid those words since we take an element from the stack and set it to the binding, then use the binding to retrieve the value

```oh
1 2 swap
```

Could be also written:

```
1 2 bind (one two)
two one
```

And

```oh
1 dup
```

Could be:

```oh
1 bind one
one one
```

But obviously using swap and dup in those cases is more convenient.

Anyways if we were to use multiple values, bind will associate names with them and we will not have to care about reordering them

```oh
1 2 3 4 5 6 7
bind (one two three four five six seven)

one seven +
four five +
two six +
three four +
```

That would be a nightmare with stack operations

That said, stack based languages should never have more than 3 elements on the stack at a time.

One note about dup and bind itself when duplicating a value.

It's javascript and dup or bind do not make a real clone of a value. If the value is a number or string is immutable by js standards.

But if it's an object or array or whatever mutable, duplicating them will just duplicate a reference, not copy a value.

For example duplicating a list and then mutating it:

```oh
(1 2 3) dup pop
```

The word "pop" takes a list from the stack and calls the pop() method on that list, removing the last element of that list and pushing it on the stack. The duplicated copy created by dup will reflect the changes and in the stack the list will be shown missing the last element [[1, 2]]

dup does not prevent mutation because it does not create a copy, just duplicates a reference to the same object.

Same for bind

```oh
(1 2 3) bind list
list list pop
```

That's also why the "(" returns a closure that will create a copy every time, because "(" should act as syntax for a list literal

```js
() => put(list.slice())
```

If not, when used in a definition for example and that definition executes multiple times it would return the original list and if it were to be mutated it would reflect the changes

```oh
: my-list (1 2 3) ;
my-list pop
my-list
```

In this case ":" starts compiling for that word and finds "(" which gives it to compile element and since it's immediate 1 it executes and returns something that ":" will insert.

The execution array of my-list would be:

```js
[() => put(list.slice())]
```
So the my-list will return a fresh copy every time, pop will be operating with that copy instead of the original.

If the "(" instead returned simply

```js
() => put(list)
```

The word "pop" would be operating on the original list, then the last call to my-list would push a list with [1, 2] instead of [1, 2, 3]

Since "(" returns a copy every time there is no problem to mutate a list returned by it, but bind and dup will not have this behavior since they do not even care what the value is.










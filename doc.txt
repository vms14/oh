I'm going to lay down everything i know and think about this interpreter.

I will focus on explaining everything as much as possible from all different aspects of the language.

What i think, what i know, why exists, how it works, etc.

But there will be no particular order and all thoughts will be scattered, so it is a raw brain dump.


### What this language is?

It is a rpn stack based language written in javascript.

It tries to rely as much as possible on javascript, to provide as much as interoperation with it as possible.

The main goal is to inherit access to all the browser APIs and do everything js can do but in a weirder way.

It is also my playground to experiment with programming.

In a way it is a reflection of my current understanding about programming. Everything i know about programming is being reflected either as part of the core interpreter or as a word definition.

It grows when my understanding grows.

When my understanding grows and the current implementation does not match my understanding anymore, it gets rewritten from the scratch.

But it also amplifies my understanding.

It is a playground for my mind and a training process to teach me about almost any concept about programming.

I can test any idea without friction, integrate it to the language, combine it, drop it or evolve it.

While showing this interpreter to chatgpt and discussing about it, it told me that it's not really reflecting my understanding, but how i deal with uncertainty and that also mirrors my own learning procedure.

That in a way, it mirrors how i think.

For me this interpreter is just a playground for ideas.

An idea can be tested immediately by just creating a word definition, either in the language itself or in javascript.

New syntax can be added by just creating a function that reads the source code and returns another function that will perform the logic, or performs the logic right away.

The language does not care about almost anything.

It only cares about reading a token and turning it into a function.

Some tokens provoke arbitrary execution of code while the rest are delayed and stored as functions.

The interpreter just reads tokens and collects functions, which will be iterated and called in sequence later.

If for example it reads a number like "1", it will create a closure in javascript that stores that number and when executed will push it on the stack.

1 becomes in a way:

```js
let value = 1; return () => stack.push(value)
```

So the interpreter just reads a number and captures it, returning a function, that will get executed later.

I call the process of generating functions the compile procedure or compile time, and I see the execution of those functions as the runtime of the interpreter.

It is not compiling anything, but delaying executions and precomputing decisions.

The goal of the compiling procedure is to avoid as much as possible runtime overhead, mainly runtime lookups.

It is not the same to lookup what a word means once, than 200 times in a loop.

Although performance is not the real reason the compiling procedure actually exists.

The main reason is to freeze definitions so when a definition relies on another definition and gets "compiled", if the other definition gets redefined, this defintion that used the other one will not be affected by the other definition being updated.

In other words, it avoids dynamic binding.

All the words are found in an environment in the form of a function. An environment is just:

```js
{ parent: pointer_to_another_environment_or_undef, word: {} }
```

The compiling procedure just searches for the chain of environments and looks whether the token is found in the word: {} object that serves as a lookup table for words. All words are stored in that word: {} object, the interpreter just finds and returns them.

When we are creating a definition, we are just reading tokens, turning them into functions, then storing those functions in an array.

The colon word is the main interface for the language to create a new definition.

It reads the name of the word that is going to be generated in the current environment and starts gathering functions and storing them into an array.

For example the definition of a word that pushes three numbers on the stack when executed:

```oh
: push-three-numbers 1 2 3 ;
```

The colon word ":" is an immediate word.

An immediate word executes at compile time.

The main procedure to turn a token into a function is a javascript function named compile element

compile element takes one argument and tries to return a function. It tries to unify everything into a function.

A token in the language will always represent an action.

This action gets represented internally by a function.

A number becomes a function that will push the number on the stack.

A word defined in the environment is just a javascript function.

A primitive word is a word defined in javascript directly like:

```js
env.word.name = () => console.log("hi i am the word named 'name'")
```

env is the current environment pointer. It is where compile element starts searching for words.

When compile element is given the argument: "name" like in: compile_element("name") in js

It will start looking from the environment pointer:

```js
 if (env.word.name)
 {
   return env.word.name
 }
```

In this case if we defined that env.word.name, it will be a javascript function, compile element will just return that function.

compile element is the whole interpreter.

It only cares turning everything into a function or excuting immediate words.

There are two types of immediate words.

What i call immediate 0 and immediate 1

The 0 or 1 is just a flag compile element uses to distinguish between those two types.

immediate 0 means "execute this right now"

immediate 1 means "execute this right now, it will return a function on the stack which you will pop from the stack and return to the caller"

If a word is immediate it will execute it, if it's immediate 0, compile element will return undefined, if it's immediate 1, that word when executed will push a function on the stack and compile element will return it

If the token does not map to a word, compile element will fallback to compile atom, compile atom tries to provide syntax sugar for literals and fancy stuff.

A token is what read word returns, read word just reads the source code until a space, newline or tab, and returns the token it has read.

Some characters are special for read word, they do not require spaces between them and constitute an entire token by themselves.

The special characters are ( ) [ ] { } ` and "

This is because those characters are used for special syntax provided in the form of immediate words.

The starting delimiters like "(" "[" and "{", are immediate words that execute at compile time and start reading from the source code, to implement a different syntax. The closing delimiters ")" "]" and "}" are just a sentinel character for those reader words. Those immediate words will read until they find in the source code the closing delimiter.

"(" "[" and "{" just call the read word function to retrieve a word and do something with it. The read word function knows both the starting and closing delimiters are special characters, so when it finds one of them it will return it without expecting spaces betwen them.

That means that for the interpreter, reading

```oh
"(1 2 3)"
```

is equivalent to reading

```oh
 ( 1 2 3 )
```

The simplest example is "(" which is an immediate 1 word. Being an immediate word means compile element will execute it when it receives the "(" token as its argument, and being immediate 1 means this word has to push a function on the stack, which compile element will take and return to the caller.

The read eval print loop in node will just read a line of source code and make this to become the source of the interpreter,

Then it will call read word and give whatever read word returns as the argument to compile element.

Compile element will either return undef or a function. The repl will store that function into an array.

After all the source code has been exhausted, the repl will iterate through this array and call all the functions compile element returned.

If we were to type something in the repl like:

```oh
1 2 3
```

The repl will set the source to be the string "1 2 3", then create an empty array, then start calling read word until read word returns undefined, meaning the source is exhausted, giving whatever read word returns to compile element and if compile element returns a function, it will get appended to that array, After read word signals end of source code by returning undefined, the repl will take this array and iterate it, calling all the functions.

In this case what it would do is to call compile element three times

```js
compile_element("1")
compile_element("2")
compile_element("3")
```

Compile element will search in the environments starting from the current environment, fail because there is no word defined 1, 2 or 3 in any environment, then fallback to compile atom.

Compile atom only applies several regular expression checks on that atom to determine what it is.

In the case of 1 2 and 3, they match the number_regex regular expression which is:

```js
const number_regex = /^-?\d+(\.?\d*)$/
```

And it will return a function that will push that number on the stack:

```js
if (atom.match(number_regex))
{
  const number = parseFloat(atom)
  return () => put(number)
}
```

So compile element will return those closures for those numbers and the repl will store them into an array

Similar in a way to this, but the numbers are lexical js variables instead of the literal numbers:

```js
[() => put(1), () => put(2), () => put(3)]
```

That's what the repl will generate from reading the line of input "1 2 3"

Then it will just iterate this array and call all those functions in order.

That moment is what i call runtime, the execution of the collected functions.

Compile time is just when we are generating them, when we call compile_element(read_word()) and gather the results into an array.

If we are gathering functions into an array, and we give compile_element the name of an immediate 0 word, compile_element will return nothing, it will just evaluate that word right away, and we won't get anything to push on our array.

If we instead give it the name of an immediate 1 word, compile element will execute that word, the word will generate a function and return it on the stack, compile element will return us that function and we will append it to our array

This is all the interpreter does, the rest is just to create words, either normal words, immediate 0 or immediate 1 words and maybe extend compile atom with more regular expressions.

The interpreter does not know what syntax is, syntax is just tokens separated by spaces, newlines or tabs, and some characters that are a token by themselves.

It does not know what an if statement is, what a loop is, etc. It just knows there are environments which store words, those words are either returned or executed and some words might return a compilation unit in form of a function when executed. Plus the compile atom function which is just a bunch of regular expressions.

If compile atom runs all the chain of checks on this atom and does not recognize it, it will trigger an error.

New syntax not integrated in compile atom as a regular expression is implemented by immediate words that execute at compile time, read the source code either by characters or by calling read_word and perform logic at compile time, add entries into the compilation time environments, and/or return a function on the stack that will get inserted to the compilation array.

The "(" is the simplest example of an immediate 1 word that implements new syntax and returns a function on the stack that will get appended to our compilation array.

The "(" internally calls a js function named build_list, that creates an array and calls read word until read word returns the ")" token.

```oh
(1 2 3)
```

If we were to type this in the node repl, the repl will call read word and read word will return "("

Note that "(" does not require spaces and read_word returns "(" alone instead of "(1" because "( ) [ ] { }" are special characters that read word returns when it finds them without expecting any space.

So for the interpreter this will always be seen as if we type: " ( 1 2 3 ) "

Then the repl calls compile_element("(") and compile element finds this word in the root environment and sees that is an immediate 1 word, so it executes it and expects it to return a function on the stack, which will return to the repl and the repl will store in the array of functions is generating.

the "(" word will execute and will start calling read word until read word returns ")", it will just store all those results into an array.

This is an aproximation of what it does when compile element calls it:

```js
const list = []
let word
while ((word = read_word()) !== ")")
{
  list.push(word)
}
stack.push(() => put([...list])
```

* The closure returns a new copy of the list instead of the original one to avoid mutation of that list, so every time you execute the closure that "(" generated, it will return a fresh copy of the list that was been built at compile time.

When "(" receives the ")" token from read word, it stops reading words and generates a javascript closure that when executed will push that array on the stack, then it just pushes this closure on the stack, compile element takes this closure and returns it to the repl and the repl stores it into the array of functions it is gathering. Once the repl knows there is no more input to compile, it will run the functions in this array. In this case the array will contain:

```js
[() => put([...list])]

```

And it will just iterate it and call that function.

That function is the closure the "(" word generated from reading words and pushed on the stack at compile time.

That's how syntax, control operators, loops, etc is added into the language.

The language does not know what "(" does more than that "it executes and returns something at compile time"

The "(" extends compile element in a way, since compile element trusts this word to generate a compilation unit.

I like how the language does not care about anything, yet it can be extended almost infinitely by immediate words.

For example the interpreter does not know what "if" means, except that "if" is an immediate 1 word.

the "if" word will read the source code and generate a closure that when executed, will perform the logic of the "if" statement.

Everything in this language is mainly delayed execution and partial evaluation.

I tried my best into unifying everything into a function. Including variables.

Variables do not exist in this language, the word bind creates something that acts as a dynamic variable, but it's just a closure that pushes a value on the stack and this value can be mutated.

The reason i say i tried to unify even variables into a function is because bind generates a function that behaves as a variable.

The function is just this:

```js
const binding = () => put(binding.value)
```

It relies on the fact that javascript functions are objects to just store the value property on the function object itself, making that closure become a cell or storage unit that when executed will push that value on the stack.

In order to mutate a value we just need a reference to that function and do something like:

```js
binding.value = 3
```

And now when executed this function will push the number 3 on the stack.


That means that everything that stores a reference of that function is also storing a way to access and mutate this value.

It also implies that this binding is dynamic, if you mutate the value, everything that has a reference to that function will see the effects, since the function just pushes that value on the stack when executed, the value will be whatever value it has the moment this function gets executed, so the value will always be the last value being set.

The environments are cool.

Any definition that starts reading words and compiling them by calling compile atom and read word, will likely create a new environment before doing anything, and set this new environment as the current environment by overriding the env pointer, which is a global pointer used by the interpreter to point to whatever the current environment is and gets overwritten several times during compilation to always point to the current compilation environment. After a definition has been compiled, the current environment pointer will point back to the previous environment. Every definition that messes with the current environment pointer will store a reference to what it was pointing to and later restore it to point back to that reference.

The main example of a definition is the colon word, which is an immediate 0 word:

```js
env.word[":"] = () =>
{
  const name = read_word()
  const code = []
  const old_environment_pointer = env
  env = make_env(env)
  let word
  while ((word = read_word()) !== ';')
  {
    const value = compile_element(word)
    if (value)
    {
      code.push(value)
    }
  }
  env = old_environment_pointer
  env.word[name] = () => { for (let fun of code) { fun() }}
}
env.word[":"].immediate = 0
```

That's mainly what the ":" word does, although it internally uses a function that performs this behavior, since it's a common pattern for any word that creates a definition.

The colon word executes at compile time, it's an immediate 0 word, so compile element executes it and returns undefined, because immediate 0 words just execute at compile time, but do not need to return any function on the stack, since they are mainly executed to perform some sort of side effect.

In the case of the colon word, the side effect is to generate a new word definition in the current environment.

The current environment when the interpreter starts, points to the root environment, which is an environment that has no parent:

```js
let env = { parent: undefined, word: {} }
const root = env
```

root is just a pointer to the first environment ever created, which is the root environment.

When we type in the repl:

```oh
: some-word-name 1 2 3 ;
```

The repl calls compile_element(":") and compile element finds ":" which is defined in the root environment and is an immediate 0 word.

Then the function stored in root.word[":"] is executed

This function stores a reference of whatever "env" was pointing to, then creates a new environment and overrides "env" to point to it, so now compile element will start searching words there, this environment inherits from whatever was the current environment when ":" gets executed at compile time.

Since it's a top level definition, the environment created will be a child of the root environment, and now the current environment will be this one.

Then it will start compiling 1, 2 and 3, until it reads the semicolon that signals the end of this definition.

Then it restores the current environment pointer to point back to the root environment and registers this definition into the root environment since it was the current environment when ":" was executed.

Now the root environment is:

```js
root = { parent: undefined, word { 'some-word-name': () => { for (let fun of code) { fun() }} } }
```

The environment that was generated by the colon word has been lost and garbage collected by javascript, since that environment was only temporarily referenced by the current environment pointer, but once the colon word ends compiling, the current environment pointer now points to the root environment again and no one has stored a reference to that new environment, so js schedules that environment to get collected for the gc.

That means that the environments that are created in definitions exist only during the compile time of that definition, they inherit from whatever environment was the current environment at the time of that definition and they get destroyed after the definition ends.

It is lexical scope at compile time.

A definition can be created inside another definition. It will generate a new environment that inherits from the parent, then compile stuff, then restore the environment pointer to point to the previous one. If that definition gets inserted into the previous environment, the outer definition will find it because it will call compile element and compile element will see that word registered in the environment.

The colon word creates definitions at compile time and injects them into whatever was the current environment at that point.

Note that in our some-word-name example, we were typing this into the repl and the repl called compile element to evaluate ":" at compile time, since ":" is an immediate 0 word, which means that just executes and returns nothing, compile element returned undefined and the repl did not append any function on its compilation array, since the repl just calls compile element until the source code is exhausted, then stores those functions in an array, and after there is no more input it iterates this array, calling each function in sequence.

The repl and a definition of a word are similar in the way that they collect functions into an array and their execution is just to run those functions in sequence later.

In the case of the line that only contains a definition like ": some-word-name 1 2 3 ;" the repl calls read word, read word returns ":" and the repl gives that to compile element, compile element executes ":" and returns undefined, so the compilation array of the repl is empty.

If the line were instead

```oh
: some-word name 1 2 3 ; some-word-name
```

The repl will call compile element with ":" as before, ":" will read words until it finds the ";" semicolon, then compile element will return nothing, the repl will call read word again and this time read word returns the string "some-word-name" which the repl gives to compile element and since ":" has registered this word in the root environment, compile element finds it and returns it to the repl, so the compile array of the repl contains the javascript function that ":" created:

```js
const the_repl_execution_array = [() => { for (let fun of code) { fun() } }]
```

and the repl will keep gathering functions until read word signals eof by returning undefined.

Then the repl will iterate that array and call all the functions.

```js
for (let fun of the_repl_execution_array)
{
  fun()
}
```

Which is exactly the same kind of function the colon word and any other definition generates.

Just note that when compile element returns undefined, which is when an immediate 0 gets executed, nothing is pushed in those arrays.

And when an immediate 1 gets executed, the function that immediate word returns on the stack gets appended to those arrays.

If the repl had the line ": some-word-name 1 2 3 ;"

The word definition will be like:

```js
env.word.name = () => { for (let fun of [() => put(1), () => put(2), () => put(3)]) { fun() } }
```

And the repl execution array will be empty, since it only has read ":", compile element returned nothing because ":" is immediate 0, so the repl did not append anything, then the repl calls read word again, but read word returns undefined too, because the line had no more input and the ":" word has exhausted the input itself, reading until a terminating semicolon ";".

That means that if a ":" is found inside the code of an outer colon definition, the outer ":" will call compile element with the ":" argument, which makes this process recursive, meaning that any immediate word that calls compile element will recurse if the argument it gives to it is the name of that immediate word itself, since compile element will just find that this word is immediate and execute it.

That's how or why colon definitions can be nested:

```oh
: outer-definition
  : inner-definition 1 2 3 ;
;
```

* Just as a note, the node repl only reads by lines so it would choke on this code being separated by newlines, so in the node repl would have to be one line: ": outer-definition : inner-definition 1 2 3 ; ;" This is a strong limitation of the node repl. Note also that if we were loading an entire file, either from node or the browser, we would be creating an array of functions and read and compile all the words in the entire file, storing all the functions in the array, then after we find the end of the file, we will iterate this array and execute all the functions, mirroring what the repl does for a line and what the colon word does for a definition.










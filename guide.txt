A Guide to the "Text" Programming Language

This document serves as a tutorial and reference for the "Text" programming language, a stack-based, concatenative language interpreter implemented in JavaScript. It covers the core concepts, syntax, control flow, and the extensive library of built-in functions, known as "words."

1. Core Concepts

The language's operation revolves around a few central ideas: the stack, environments, and words.

1.1 The Stack

The stack is the primary data structure. All operations and words interact with it by pushing values onto it or popping values from it. Data is placed on the stack, and words consume that data, perform an action, and may push a result back onto the stack.

1.2 Words and The Environment

A word is a command or function. The interpreter reads text, breaks it into words separated by whitespace, and executes the corresponding function for each word.

Words are stored in an environment, which is a dictionary mapping word names to their functions. Environments are lexically scoped; if a word is not found in the current environment, the interpreter searches its parent environment, allowing for modularity and local definitions.

1.3 Execution Model

Code is read and parsed into a sequence of elements. These elements are then "compiled" into a list of executable JavaScript functions. Running the code involves simply iterating through this list and executing each function.

* Runtime vs. Compile Time: Most words are compiled into functions that execute when the program is run. However, some words are marked as immediate, meaning they execute immediately during the compilation phase. This is used for control flow and defining new words.
* Asynchronous Execution: The language can operate in two modes. By default, it is synchronous. The wait word enables an asynchronous mode where the interpreter can await promises that appear on the stack, allowing for non-blocking operations. no-wait reverts to the default synchronous behavior.

2. Basic Syntax and Operations

2.1 Data Types

Type	Syntax	Description
Number	-?\d+(\.?\d*)	A standard floating-point number. Example: 42, -3.14. These are compiled into functions that push the number onto the stack.
String	'string-literal	An unquoted string prefixed with a single quote. This pushes the literal string value string-literal onto the stack.
String	"content"	A double-quoted string. This reads all characters until the next ", handling standard escape sequences (\n, \t, etc.). It compiles to a function that pushes the string content onto the stack.
String	`*content*`	A backtick-quoted string. Behaves identically to a double-quoted string.
List	( element1 element2 ... )	A list of data elements. This is parsed at compile time. It is compiled into a function that pushes a new array containing the elements onto the stack. Lists can be nested.
Comment	--- rest of line	A single-line comment. The interpreter will ignore all text from --- until the next newline.

2.2 Stack Manipulation

These are fundamental words for managing the stack's contents.

Word	Description
dup	Duplicates the top element of the stack.
swap	Swaps the top two elements of the stack.
drop	Removes the top element from the stack.
2drop	Removes the top two elements from the stack.
3drop	Removes the top three elements from the stack.
4drop	Removes the top four elements from the stack.
r	Resets and clears the entire stack.
s	Logs the current state of the entire stack to the console for debugging.
log	Pops the top element from the stack and logs it to the console.
list	Pops a number n from the stack, then collects the next n items into a list and pushes it.
flatten	Pops a list from the stack and pushes its individual elements onto the stack.

2.3 Arithmetic Operations

Arithmetic words pop two numbers from the stack, perform the operation, and push the result.

Word	Operation
+	Addition
..	Addition
-	Subtraction
*	Multiplication
/	Division
%	Modulo

3. Control Flow and Definitions

3.1 Quotations and Evaluation

A quotation is a piece of compiled, executable code that is treated as data. It can be stored, passed around, and executed on demand.

* { ... }: This is an immediate word that reads all subsequent words until a matching }. It compiles this sequence into a single function (a quotation) and pushes that function onto the stack.
* eval: Pops a quotation from the stack and executes it.
* eval-string: Pops a string from the stack, compiles it, and executes it.

3.2 Conditional Logic

The if word provides conditional execution. It is an immediate word.

* if condition then true-branch else false-branch end:
  1. The words in the condition block are compiled and executed.
  2. This must result in a boolean value on the stack.
  3. If the value is true, the true-branch code is executed.
  4. If the value is false, the false-branch code is executed.
  5. The else branch is optional.
  6. The keywords then and end are required to delimit the branches.

3.3 Case Statements

The case word provides multi-way branching, similar to a switch statement.

* case value1 code1 value2 code2 else default-code end:
  1. Pops a value from the stack to be tested.
  2. It compares the value against each specified case (value1, value2, etc.).
  3. If a match is found, the corresponding code block (code1, code2) is executed.
  4. The value can be a literal, a list ( ... ), or a string " ... ".
  5. If else is provided, its code runs if no other cases match.

3.4 Defining New Words

You can extend the language by defining new words.

* : word-name ... ;: Defines a new word. word-name is the name, and the code between it and the terminating ; is the body. The new word is added to the current environment. This creates a word with a shared environment.
* defun word-name ... end: Defines a new word that, when executed, creates its own new environment inheriting from the definition environment. This provides stronger encapsulation.
* block ... end: An immediate word that compiles the code until end into a quotation that runs in a new, empty environment.
* lambda ... end: An immediate word that compiles the code until end into a quotation, pushing a function onto the stack that, when called, pushes the quotation to the stack. This quotation runs in a new, empty environment.

3.5 Variables and Bindings

The language supports both compile-time and runtime variable binding.

Syntax	Description
:name	Pops a value from the stack and binds it to name in the current environment at compile time. The compiled code is a function that pushes this bound value.
:name:	Same as :name, but also pushes the value back onto the stack after binding.
name:	Compiles into a function that looks up name in the environment at runtime and executes it. This is for dynamic dispatch.
declare name	Creates a variable name in the current environment, initialized to 0. declare ( name1 name2 ) declares multiple variables.
bind name	Creates a variable name and pushes a quotation to the stack. When this quotation is called, it pops a value and assigns it to name. bind ( name1 name2 ) creates multiple variables and a quotation that assigns multiple values from the stack. This is an immediate word.
set name	An immediate word. Pops a value and assigns it to the pre-existing binding name.
get name	An immediate word. Pushes the value of the binding name onto the stack.
increment name	An immediate word. Pops a value and adds it to the binding name.
decrement name	An immediate word. Pops a value and subtracts it from the binding name.
increment-by-one name	An immediate word. Increments the value of name by one.
decrement-by-one name	An immediate word. Decrements the value of name by one.

4. Interacting with JavaScript

A powerful feature of the language is its seamless integration with the host JavaScript environment.

4.1 Property Access and Mutation

Dot notation is used to interact with JavaScript objects.

Syntax	Description
object.property	Given a variable object that holds a JS object, this compiles to code that pushes the value of object.property onto the stack. Hyphenated properties can be used (obj.prop-name becomes obj.propName).
.property	Pops an object from the stack and pushes the value of its property onto the stack.
object.property!	Pops a value from the stack and assigns it to object.property.
.property!	Pops a value, then an object, from the stack. Assigns the value to the object's property.
get-property	Pops a property name, then an object, from the stack. Pushes the property's value.

4.2 Method Calls

Prefixes are used to call methods on JavaScript objects.

Syntax	Description
-method	Pops an object from the stack, calls its method(), and pushes the return value.
--method	Pops a list of arguments, then an object. Calls object.method(...args) and pushes the return value.
~method	Pops an object and calls its method(). The return value is discarded.
~~method	Pops a list of arguments, then an object. Calls object.method(...args) and discards the return value.

5. Browser Environment Integration

When run in a web browser, the language loads a rich set of words for interacting with the DOM, canvas, and browser APIs. Code can be embedded in HTML using <oh> tags, either via a src attribute or inline content.

<!-- Load from external file -->
<oh src="my-app.txt"></oh>

<!-- Execute inline code -->
<oh>
  'h1' element
  'Hello from Text!' 'text'
  ( ) dom
  to-body
</oh>


5.1 The dom Word

The dom word is a powerful tool for creating DOM trees from lists. It takes a list from the stack and constructs an HTML element.

Syntax: ( 'tag-name' directive1 value1 directive2 ... ) dom

Directive	Description	Example
( ... )	A nested list is treated as a child element and is recursively processed by dom.	( 'div' ( 'p' 'text' "child" ) )
'text'	The next item in the list is added as the element's textContent.	( 'p' 'text' "Hello" )
.classname	Adds a CSS class. Example: .container.	( 'div' .main-content )
#id	Sets the element's ID. Example: #main.	( 'div' #app-root )
-attr	The next item in the list is set as the value for the attribute. Example: -href "url".	( 'a' -href "https://..." )
:name	Binds the created DOM element to the variable name in the current environment.	( 'canvas' :my-canvas )
@event	The next item, a quotation or list, is registered as an event listener for the specified event type. The DOM event object is available via the event word inside the listener.	( 'button' @click { ... } )
'reader'	reader word-name property-name: Creates a word word-name that reads element.propertyName.	( 'input' reader 'read-val' 'value' )
'writer'	writer word-name property-name: Creates a word word-name that pops a value and sets element.propertyName.	( 'input' writer 'write-val' 'value' )

5.2 Browser Word Reference

Word	Description
Document/Window	
body	Pushes document.body.
window	Pushes the global window object.
document	Pushes the document object.
params	Pushes the URLSearchParams from the current URL.
query	Pushes an object of key-value pairs from the URL query string.
alert	Pops a value and displays it in a browser alert dialog.
fetch	Pops a URL and pushes the fetch promise. Requires wait mode.
DOM Manipulation	
element	Pops a tag name (e.g., 'div') and pushes a new DOM element.
to-body	Pops an element or list of elements and appends it/them to document.body.
append	Pops a child element, then a parent element, and appends the child to the parent.
Canvas & Graphics	
make-canvas	Creates a fullscreen canvas, appends it to the body, and sets the internal rendering context (ctx).
canvas	Pushes the canvas element created by make-canvas.
set-ctx	Pops a canvas element and sets its 2D rendering context as the active ctx.
clear	Clears the entire canvas.
rectangle	Pops [x, y, width, height] and draws a filled rectangle.
color	Pops a color string and sets it as the fillStyle for drawing.
animation	Pops a quotation and runs it on every animation frame using requestAnimationFrame.
Styling & Assets	
style	Pops a CSS string and sets it as the content of a dedicated <style> tag in the <head>.
style-append	Pops a CSS string and appends it to the dedicated <style> tag.
css	Pops a list of lists describing CSS rules and pushes a formatted CSS string. See css function details below.
add-font	Pops [type, url] and adds a new FontFace to the document.
image	Pops a URL src, creates an Image, and pushes a promise that resolves with the loaded image.
images	Pops a list of URLs and pushes a promise that resolves with a list of all loaded images.
Events	
handler	An immediate word that creates an event handler quotation. Inside the handler, the word event is available.

CSS Generation with the css Word

The css word transforms a structured list into a CSS string. The input is a list of lists, where each inner list represents a CSS rule.

Example:

(
  ( 'body'
    'background-color' '#333'
    'color' 'white'
  )
  ( 'h1'
    'font-family' ( 'Helvetica' 'Arial' 'sans-serif' )
    'font-size' '2em'
  )
) css style


6. Full Word Reference

General Purpose

Word	Category	Description
nop	Utility	No operation. Does nothing.
find	Meta	Pops a string name and pushes the word function associated with it, if found.
compile	Meta	Pops a data element (string, list) and pushes its compiled function.
compile-string	Meta	Pops a string, compiles it, and pushes the resulting quotation.
console	Utility	Pushes the JavaScript console object onto the stack.
trace	Debugging	Enables trace mode, logging each word and the stack state as it executes.
no-trace	Debugging	Disables trace mode.

Data Structures & Iteration

Word	Category	Description
object	Object	Pops a list [key1, val1, key2, val2] and pushes the object {key1: val1, ...}.
obj	Object	Pops a list of keys, then pops that many values, creating an object.
properties	Object	Pops a list of properties, then an object. Pushes the value of each property.
keys	Object	Pops an object and pushes a list of its keys.
values	Object	Pops an object and pushes a list of its values.
entries	Object	Pops an object and pushes a list of its [key, value] pairs.
@	List	"Interpolate". Pops a list, replaces any , with a value from the stack, and pushes the new list.
iterate	List	Pops a quotation, then a list. Executes the quotation for each element of the list (element is pushed first).
iterator	List	Pops a list and pushes an iterator object {list, pointer}.
next-element	List	Pops an iterator, advances its pointer (wrapping around), and pushes the element.
previous-element	List	Pops an iterator, moves its pointer back (wrapping around), and pushes the element.
random-element	List	Pops an iterator, sets its pointer to a random index, and pushes the element.

Asynchronous Operations

Word	Category	Description
promise	Async	Creates a promise. The block has resolve and reject words available to control the promise's state.
interval time ... end	Async	time is a number in ms. Executes the code block every time milliseconds. Pushes the interval ID.
timeout time ... end	Async	time is a number in ms. Executes the code block once after time milliseconds. Pushes the timeout ID.

String Operations

Word	Category	Description
uppercase	String	Pops a string, converts it to uppercase, and pushes the result.
lowercase	String	Pops a string, converts it to lowercase, and pushes the result.
remove-characters	String	Pops a list of characters, then a string. Pushes a new string with those characters removed.

Modularity

Word	Category	Description
module name ... end	Module	Creates a new environment, executes the block within it, and binds it to name.
import word	Module	Pops an environment and imports the specified word from it into the current environment.
import ( ... )	Module	Pops an environment and imports all words named in the list.
import-all	Module	Pops an environment and imports all of its words into the current environment.

Miscellaneous

Word	Category	Description
random	Utility	Pops a list, object, or number. Pushes a random element, value, or integer up to that number.
random-key	Object	Pops an object and pushes one of its keys at random.

